<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>A-Frame Shooting Game</title>
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; font-family: Arial, Helvetica, sans-serif; }
    #ui {
      position: absolute; top: 12px; left: 12px; z-index: 10; color: white;
      background: rgba(0,0,0,0.4); padding: 10px; border-radius: 8px; min-width: 180px;
    }
    #ui button { margin-top: 6px; width: 100%; padding: 8px; border: none; border-radius: 6px; }
    #centerHint { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: rgba(255,255,255,0.6); pointer-events: none; }
    #message { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); color: white; background: rgba(0,0,0,0.5); padding: 6px 10px; border-radius: 6px; }
  </style>
</head>
<body>
  <div id="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <button id="startBtn">Start Game</button>
    <button id="restartBtn" style="display:none">Restart</button>
    <p style="font-size:12px;margin:6px 0 0 0">Controls: Mouse click to shoot (desktop). On VR controllers, press trigger.</p>
  </div>
  <div id="centerHint">+ Aim & Shoot +</div>
  <div id="message"></div>

  <a-scene background="color: #111">
    <a-entity id="player" position="0 1.6 0">
      <a-entity camera look-controls wasd-controls></a-entity>
    </a-entity>

    <!-- Right-hand shooter (also supports mouse for desktop) -->
    <a-entity id="shooter" position="0 1.6 0" shooter></a-entity>

    <!-- Lighting -->
    <a-entity light="type: ambient; intensity: 0.6"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="-1 2 1"></a-entity>

    <!-- Floor -->
    <a-plane rotation="-90 0 0" width="60" height="60" color="#222" position="0 0 0"></a-plane>

    <!-- Target container -->
    <a-entity id="targets"></a-entity>

    <!-- Sky -->
    <a-sky color="#000"></a-sky>
  </a-scene>

  <script>
    // Game state
    const state = { score: 0, lives: 3, running: false, spawnInterval: null, moveInterval: null };
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const messageEl = document.getElementById('message');

    // Utility - random between
    function rand(min, max){ return Math.random()*(max-min)+min; }

    // Shooters component: handles mouse click and VR controller trigger
    AFRAME.registerComponent('shooter', {
      init: function(){
        const sceneEl = this.el.sceneEl;
        // Mouse (desktop)
        window.addEventListener('mousedown', (e)=>{
          if(state.running) shootFromCamera();
        });
        // VR controller support (triggerdown)
        sceneEl.addEventListener('controllerconnected', (evt)=>{
          const controller = evt.detail;
          // attach event listeners to controller entity when available
        });

        // Also listen for trigger events from controller entities
        sceneEl.addEventListener('triggerdown', ()=>{ if(state.running) shootFromCamera(); });
      }
    });

    // Shoot a bullet from camera position forward
    function shootFromCamera(){
      const scene = document.querySelector('a-scene');
      const cam = scene.querySelector('[camera]');
      const camObj = cam.object3D;
      const bullet = document.createElement('a-sphere');
      bullet.setAttribute('radius', 0.05);
      bullet.setAttribute('class', 'bullet');
      bullet.setAttribute('geometry','primitive: sphere; radius: 0.05');
      bullet.setAttribute('material','color: #ffcc00; emissive: #ffcc00');

      // position slightly in front of camera
      const pos = new THREE.Vector3();
      camObj.getWorldPosition(pos);
      const dir = new THREE.Vector3(0,0,-1);
      camObj.getWorldDirection(dir);
      const start = pos.clone().add(dir.clone().multiplyScalar(0.4));
      bullet.setAttribute('position', `${start.x} ${start.y} ${start.z}`);

      // store velocity on a THREE.Vector3
      bullet.velocity = dir.clone().multiplyScalar(0.7 + Math.random()*0.3);
      scene.appendChild(bullet);

      // remove after 4s
      setTimeout(()=>{ if(bullet.parentNode) bullet.parentNode.removeChild(bullet); }, 4000);
    }

    // Spawn targets periodically
    function spawnTarget(){
      const container = document.getElementById('targets');
      const scene = document.querySelector('a-scene');
      const t = document.createElement('a-box');
      const size = rand(0.4, 0.9);
      t.setAttribute('width', size); t.setAttribute('height', size); t.setAttribute('depth', size);
      t.setAttribute('material', `color: hsl(${Math.floor(rand(0,360))} 80% 60%)`);
      // spawn in front of player, random X and Y
      const z = -rand(6, 12);
      const x = rand(-5, 5);
      const y = rand(0.7, 3.0);
      t.setAttribute('position', `${x} ${y} ${z}`);
      t.targetHP = Math.ceil(rand(1,3));
      t.classList.add('target');
      container.appendChild(t);

      // Each target slowly moves toward player
      const speed = rand(0.002, 0.01);
      t.tick = function(time, delta){
        const pos = this.object3D.position;
        pos.z += speed * delta; // move forward (z increases toward 0)
        // if reached near player -> lose life
        if(pos.z > -0.6){
          if(this.parentNode) this.parentNode.removeChild(this);
          loseLife();
        }
      };
    }

    function loseLife(){
      state.lives -= 1; livesEl.textContent = state.lives;
      showMessage('You lost a life!');
      if(state.lives <= 0){ endGame(); }
    }

    // Collision detection loop
    function collisionLoop(){
      const scene = document.querySelector('a-scene');
      const bullets = Array.from(document.querySelectorAll('.bullet'));
      const targets = Array.from(document.querySelectorAll('.target'));
      for(const b of bullets){
        const bPos = b.object3D.position;
        for(const t of targets){
          const tPos = t.object3D.position;
          const dist = bPos.distanceTo(tPos);
          const tRadius = Math.max(t.getAttribute('width')||0.5, t.getAttribute('height')||0.5)/2;
          if(dist < 0.3 + tRadius){
            // hit
            // remove bullet
            if(b.parentNode) b.parentNode.removeChild(b);
            // damage target
            t.targetHP -= 1;
            // small scale animation to show hit
            const s = t.object3D.scale;
            t.object3D.scale.set(s.x*0.9, s.y*0.9, s.z*0.9);
            setTimeout(()=>{ if(t.object3D) t.object3D.scale.set(1,1,1); }, 120);
            if(t.targetHP <= 0){
              // remove target and increment score
              if(t.parentNode) t.parentNode.removeChild(t);
              addScore(10);
              spawnExplosion(tPos, t.object3D.scale.length());
            } else {
              addScore(4);
            }
            break; // bullet handled
          }
        }
      }
    }

    // Explosion effect (simple particles)
    function spawnExplosion(position, scaleFactor){
      const scene = document.querySelector('a-scene');
      for(let i=0;i<12;i++){
        const p = document.createElement('a-sphere');
        p.setAttribute('radius', 0.05*scaleFactor);
        p.setAttribute('material', 'color: #ff4444');
        p.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
        p.velocity = new THREE.Vector3(rand(-0.02,0.02), rand(-0.02,0.02), rand(-0.02,0.02));
        scene.appendChild(p);
        setTimeout(()=>{ if(p.parentNode) p.parentNode.removeChild(p); }, 800);
      }
    }

    // Move particles and bullets via animation loop
    function moveLoop(delta){
      const scene = document.querySelector('a-scene');
      const bullets = Array.from(document.querySelectorAll('.bullet'));
      for(const b of bullets){ if(b.velocity){ const pos = b.object3D.position; pos.add(b.velocity.clone().multiplyScalar(delta/16.6)); } }
      // particles have velocity too
      const spheres = Array.from(scene.querySelectorAll('a-sphere'));
      for(const s of spheres){ if(s.velocity){ const pos = s.object3D.position; pos.add(s.velocity.clone().multiplyScalar(delta/16.6)); s.object3D.rotation.x += 0.1; } }
    }

    // Score handling
    function addScore(n){ state.score += n; scoreEl.textContent = state.score; }

    function showMessage(txt, ms=1500){ messageEl.textContent = txt; if(ms>0){ setTimeout(()=>{ messageEl.textContent = ''; }, ms); } }

    function startGame(){
      // reset state
      state.score = 0; state.lives = 3; state.running = true;
      scoreEl.textContent = state.score; livesEl.textContent = state.lives;
      document.getElementById('startBtn').style.display='none';
      document.getElementById('restartBtn').style.display='none';
      showMessage('Game started!');

      // spawn targets every 900ms
      state.spawnInterval = setInterval(spawnTarget, 900);

      // collision check every 80ms
      state.collisionTimer = setInterval(collisionLoop, 80);

      // move loop using rAF for smoothness
      let last = performance.now();
      function rafLoop(now){
        const delta = now - last; last = now;
        moveLoop(delta);
        if(state.running) requestAnimationFrame(rafLoop);
      }
      requestAnimationFrame(rafLoop);
    }

    function endGame(){
      state.running = false;
      clearInterval(state.spawnInterval); clearInterval(state.collisionTimer);
      showMessage('Game Over! Score: ' + state.score, 4000);
      document.getElementById('restartBtn').style.display='block';
    }

    // Buttons
    document.getElementById('startBtn').addEventListener('click', ()=>{ startGame(); });
    document.getElementById('restartBtn').addEventListener('click', ()=>{
      // cleanup targets and bullets
      document.querySelectorAll('.target, .bullet').forEach(el=>el.remove());
      document.getElementById('restartBtn').style.display='none';
      startGame();
    });

    // Hook into scene tick for target ticks
    const sceneEl = document.querySelector('a-scene');
    sceneEl.addEventListener('loaded', ()=>{
      // general game loop to call tick on dynamic elements
      let last = performance.now();
      function loop(now){
        const delta = now - last; last = now;
        // call tick on dynamic targets
        const targets = Array.from(document.querySelectorAll('.target'));
        for(const t of targets){ if(typeof t.tick === 'function') t.tick(now, delta); }
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    });

  </script>
</body>
</html>
